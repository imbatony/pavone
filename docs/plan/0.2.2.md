# PAVOne v0.2.2 开发计划

## 版本概述

本版本主要聚焦于**插件功能完善和架构统一**，将现有提取器插件升级为复合型插件，并新增文件整理功能。

**主要目标**:
- 将 JTable 和 Memojav 提取器升级为复合型插件（搜索 + 元数据 + 下载）
- 实现 JTable 和 Memojav 的搜索功能
- 开发文件整理命令，自动化视频文件管理

**版本依赖**: 基于 v0.2.1 的重构成果

---

## 1. 插件架构统一 (优先级: 高)

### 1.1 背景分析

**当前状态**:
- ✅ **MissAV**: 已实现复合型插件（搜索 + 元数据 + 下载）
- ✅ **AV01**: 已实现复合型插件（搜索 + 元数据 + 下载）
- ⚠️ **JTable**: 仅实现提取器功能，包含部分元数据提取逻辑
- ⚠️ **Memojav**: 仅实现提取器功能，包含部分元数据提取逻辑

**问题**:
1. JTable 和 Memojav 在提取器中混合了元数据提取逻辑
2. 缺少独立的搜索功能
3. 架构不一致，不利于维护和扩展

### 1.2 JTableExtractor 升级为复合型插件

#### 1.2.1 当前架构分析

**文件**: `pavone/plugins/extractors/jtable.py`

**当前功能**:
- ✅ URL处理和验证
- ✅ M3U8链接提取
- ✅ 元数据提取（标题、代码、演员、发布日期、类型、标签等）
- ✅ 封面图片提取
- ❌ 缺少搜索功能

**代码特征**:
```python
class JTableExtractor(ExtractorPlugin):
    def extract(self, url: str) -> List[OperationItem]:
        # 1. 提取m3u8链接
        # 2. 提取元数据（混合在extractor中）
        # 3. 创建MetadataBuilder
        # 4. 创建OperationItemBuilder
```

#### 1.2.2 重构任务

##### 任务 1.1: 创建 JTablePlugin 复合插件
- [ ] **新建文件**: `pavone/plugins/jtable_plugin.py`
- [ ] **实现接口**:
  - `BasePlugin` (基础插件)
  - 实现搜索、元数据提取、视频下载三种功能
- [ ] **代码迁移**:
  - 从 `extractors/jtable.py` 迁移元数据提取逻辑
  - 从 `extractors/jtable.py` 迁移下载链接提取逻辑
  - 新增搜索功能实现

**新架构**:
```python
class JTablePlugin(BasePlugin):
    """JTable统一插件：支持搜索、元数据提取和视频下载"""
    
    # 搜索功能
    def search(self, keyword: str, limit: int = 20) -> List[SearchResult]:
        """搜索视频"""
        pass
    
    # 元数据提取
    def can_extract(self, identifier: str) -> bool:
        """检查是否能提取元数据"""
        pass
    
    def extract_metadata(self, identifier: str) -> Optional[MovieMetadata]:
        """提取元数据"""
        pass
    
    # 视频下载
    def can_handle(self, url: str) -> bool:
        """检查是否能处理URL"""
        pass
    
    def extract(self, url: str) -> List[OperationItem]:
        """提取下载选项"""
        pass
```

##### 任务 1.2: 实现 JTable 搜索功能
- [ ] **搜索接口设计**:
  - 支持代码搜索（如: "SSIS-123"）
  - 支持关键词搜索
  - 支持演员搜索
- [ ] **搜索结果解析**:
  - 提取视频标题
  - 提取视频代码
  - 提取视频URL
  - 提取封面图片
  - 提取基础元数据（演员、发布日期等）

**搜索API分析** (需要调研):
```python
# 假设的搜索URL格式
SEARCH_URL = "https://jp.jable.tv/search/{keyword}/"
# 或者
SEARCH_URL = "https://jp.jable.tv/search/?q={keyword}"
```

##### 任务 1.3: 测试和验证
- [ ] 单元测试
  - 搜索功能测试
  - 元数据提取测试
  - 下载链接提取测试
- [ ] 集成测试
  - 端到端流程测试
- [ ] 兼容性测试
  - 确保不影响现有功能

**预计工作量**: 3-4 天

---

### 1.3 MemojavExtractor 升级为复合型插件

#### 1.3.1 当前架构分析

**文件**: `pavone/plugins/extractors/memojav.py`

**当前功能**:
- ✅ URL处理和验证
- ✅ M3U8链接提取
- ✅ 封面图片提取
- ✅ 基础元数据处理（代码提取）
- ❌ 缺少完整元数据提取
- ❌ 缺少搜索功能

**代码特征**:
```python
class MemojavExtractor(ExtractorPlugin):
    def extract(self, url: str) -> List[OperationItem]:
        # 1. 提取m3u8链接
        # 2. 提取封面（简单）
        # 3. 使用HTMLMetadataExtractor
        # 4. 使用OperationItemBuilder
```

#### 1.3.2 重构任务

##### 任务 2.1: 创建 MemojavPlugin 复合插件
- [ ] **新建文件**: `pavone/plugins/memojav_plugin.py`
- [ ] **实现接口**:
  - `BasePlugin` (基础插件)
  - 实现搜索、元数据提取、视频下载三种功能
- [ ] **代码迁移和增强**:
  - 从 `extractors/memojav.py` 迁移下载链接提取逻辑
  - 增强元数据提取功能（补充完整字段）
  - 新增搜索功能实现

**新架构**:
```python
class MemojavPlugin(BasePlugin):
    """Memojav统一插件：支持搜索、元数据提取和视频下载"""
    
    def search(self, keyword: str, limit: int = 20) -> List[SearchResult]:
        """搜索视频"""
        pass
    
    def can_extract(self, identifier: str) -> bool:
        """检查是否能提取元数据"""
        pass
    
    def extract_metadata(self, identifier: str) -> Optional[MovieMetadata]:
        """提取完整元数据"""
        # 包括：标题、演员、导演、类型、标签、时长等
        pass
    
    def can_handle(self, url: str) -> bool:
        """检查是否能处理URL"""
        pass
    
    def extract(self, url: str) -> List[OperationItem]:
        """提取下载选项"""
        pass
```

##### 任务 2.2: 实现 Memojav 搜索功能
- [ ] **搜索接口设计**:
  - 支持代码搜索
  - 支持关键词搜索
  - 支持演员搜索
- [ ] **搜索结果解析**:
  - 提取视频标题
  - 提取视频代码
  - 提取视频URL
  - 提取封面图片

**搜索API分析** (需要调研):
```python
# 假设的搜索URL格式
SEARCH_URL = "https://memojav.com/search?q={keyword}"
# 或者
SEARCH_URL = "https://memojav.com/search/{keyword}"
```

##### 任务 2.3: 增强元数据提取
- [ ] **补充元数据字段**:
  - 演员列表
  - 导演
  - 制作商/发行商
  - 发布日期
  - 时长
  - 类型/标签
  - 评分（如果有）
- [ ] **使用工具类**:
  - `HTMLMetadataExtractor` 提取OG标签
  - `MetadataBuilder` 构建元数据对象
  - `CodeExtractUtils` 标准化代码

##### 任务 2.4: 测试和验证
- [ ] 单元测试
  - 搜索功能测试
  - 元数据提取测试（完整字段）
  - 下载链接提取测试
- [ ] 集成测试
  - 端到端流程测试
- [ ] 兼容性测试
  - 确保不影响现有功能

**预计工作量**: 3-4 天

---

### 1.4 插件注册和配置

#### 任务 3.1: 更新插件管理器
- [ ] **注册新插件**:
  - 在 `pavone/plugins/__init__.py` 中注册 `JTablePlugin`
  - 在 `pavone/plugins/__init__.py` 中注册 `MemojavPlugin`
- [ ] **移除旧插件**:
  - 移除 `extractors/jtable.py` 的注册
  - 移除 `extractors/memojav.py` 的注册
  - 或保留作为向后兼容（标记为deprecated）

#### 任务 3.2: 更新文档
- [ ] **API文档更新**:
  - JTablePlugin 使用说明
  - MemojavPlugin 使用说明
- [ ] **迁移指南**:
  - 说明架构变更
  - 提供示例代码
- [ ] **变更日志**:
  - 记录插件升级信息

**预计工作量**: 1 天

---

## 2. 文件整理功能开发 (优先级: 高)

### 2.1 功能概述

**目标**: 自动整理本地视频文件，通过搜索和元数据提取，生成标准化的文件名和目录结构。

**核心流程**:
```
原始文件 → 文件名正规化 → 搜索获取链接 → 提取元数据 → 生成操作项 → 移动/重命名文件
```

### 2.2 实现设计

#### 2.2.1 文件名正规化

**任务 4.1: 创建文件名解析工具**
- [ ] **位置**: `pavone/utils/filename_utils.py`
- [ ] **功能**:
  - 从文件名提取视频代码
  - 从文件名提取演员名
  - 识别文件名中的日期
  - 清理文件名中的无用字符

**示例**:
```python
class FilenameParser:
    """文件名解析器"""
    
    @staticmethod
    def extract_code(filename: str) -> Optional[str]:
        """从文件名提取视频代码
        
        示例:
            "[Jable]SSIS-123 美少女.mp4" -> "SSIS-123"
            "FC2-PPV-1234567.mp4" -> "FC2-PPV-1234567"
            "abc-123_uncensored.mp4" -> "ABC-123"
        """
        pass
    
    @staticmethod
    def normalize(filename: str) -> str:
        """标准化文件名
        
        - 移除方括号、圆括号中的内容
        - 移除特殊字符
        - 统一大小写
        """
        pass
    
    @staticmethod
    def extract_metadata_hints(filename: str) -> Dict[str, Any]:
        """从文件名提取元数据提示
        
        返回: {
            'code': 'SSIS-123',
            'actors': ['演员名'],
            'date': '2024-01-01',
            'studio': 'S1'
        }
        """
        pass
```

**预计工作量**: 1-2 天

---

#### 2.2.2 搜索插件调用

**任务 4.2: 创建搜索管理器**
- [ ] **位置**: `pavone/core/search_manager.py`
- [ ] **功能**:
  - 按优先级调用搜索插件
  - 合并搜索结果
  - 去重和排序

**示例**:
```python
class SearchManager:
    """搜索管理器"""
    
    def __init__(self, plugin_manager):
        self.plugin_manager = plugin_manager
        self.logger = get_logger(__name__)
    
    def search_by_priority(
        self, 
        keyword: str, 
        limit: int = 5,
        plugins: Optional[List[str]] = None
    ) -> List[SearchResult]:
        """按优先级搜索
        
        Args:
            keyword: 搜索关键词（通常是视频代码）
            limit: 每个插件的结果数量限制
            plugins: 指定使用的插件列表（None则使用所有）
        
        Returns:
            合并后的搜索结果（按优先级排序）
        """
        # 1. 获取所有搜索插件
        # 2. 按优先级排序
        # 3. 依次调用搜索
        # 4. 合并结果
        # 5. 去重（相同URL或code）
        pass
    
    def get_best_match(
        self, 
        keyword: str,
        filters: Optional[Dict[str, Any]] = None
    ) -> Optional[SearchResult]:
        """获取最佳匹配结果
        
        Args:
            keyword: 搜索关键词
            filters: 过滤条件（如: {'site': 'MissAV'}）
        
        Returns:
            最佳匹配的搜索结果
        """
        pass
```

**预计工作量**: 1-2 天

---

#### 2.2.3 元数据获取

**任务 4.3: 扩展元数据管理器**
- [ ] **位置**: `pavone/core/metadata_manager.py` (已存在，需扩展)
- [ ] **新增功能**:
  - 从搜索结果获取元数据
  - 支持批量获取
  - 缓存机制优化

**示例**:
```python
class MetadataManager:
    # 现有功能...
    
    def get_metadata_from_search_result(
        self, 
        search_result: SearchResult
    ) -> Optional[MovieMetadata]:
        """从搜索结果获取元数据
        
        流程:
        1. 尝试使用URL提取元数据（如果有extractor）
        2. 尝试使用identifier提取元数据
        3. 使用搜索结果中的基础信息构建元数据
        """
        pass
    
    def batch_get_metadata(
        self, 
        identifiers: List[str],
        callback: Optional[Callable] = None
    ) -> List[Optional[MovieMetadata]]:
        """批量获取元数据
        
        Args:
            identifiers: 标识符列表
            callback: 进度回调函数
        """
        pass
```

**预计工作量**: 1 天

---

#### 2.2.4 操作项生成（移动文件）

**任务 4.4: 创建文件操作类型**
- [ ] **位置**: `pavone/models/operation.py` (扩展现有)
- [ ] **新增操作类型**:
  - `OperationType.MOVE` - 移动文件
  - `OperationType.COPY` - 复制文件
  - `OperationType.RENAME` - 重命名文件

**示例**:
```python
from enum import Enum

class OperationType(str, Enum):
    """操作类型"""
    DOWNLOAD = "download"      # 下载（现有）
    MOVE = "move"              # 移动文件（新增）
    COPY = "copy"              # 复制文件（新增）
    RENAME = "rename"          # 重命名文件（新增）
    METADATA = "metadata"      # 元数据下载（现有）

class FileOperationItem(OperationItem):
    """文件操作项（移动/复制/重命名）"""
    
    def __init__(
        self,
        source_path: str,
        target_path: str,
        operation: OperationType,
        metadata: Optional[MovieMetadata] = None,
        **kwargs
    ):
        super().__init__(**kwargs)
        self.source_path = source_path
        self.target_path = target_path
        self.operation = operation
        self.metadata = metadata
```

**任务 4.5: 创建文件操作项构建器**
- [ ] **位置**: `pavone/utils/file_operation_builder.py`
- [ ] **功能**:
  - 根据元数据生成目标路径
  - 根据配置生成目录结构
  - 处理文件名冲突

**示例**:
```python
class FileOperationBuilder:
    """文件操作项构建器"""
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Args:
            config: 配置项
                - base_dir: 目标基础目录
                - structure: 目录结构模板
                - filename_template: 文件名模板
                - conflict_resolution: 冲突解决策略
        """
        self.config = config or {}
    
    def build_move_operation(
        self,
        source_path: str,
        metadata: MovieMetadata,
        dry_run: bool = False
    ) -> FileOperationItem:
        """构建移动操作
        
        Args:
            source_path: 源文件路径
            metadata: 视频元数据
            dry_run: 是否为模拟运行
        
        Returns:
            文件操作项
        """
        # 1. 根据模板生成目标路径
        target_path = self._generate_target_path(metadata)
        
        # 2. 处理文件名冲突
        if os.path.exists(target_path):
            target_path = self._resolve_conflict(target_path)
        
        # 3. 创建操作项
        return FileOperationItem(
            source_path=source_path,
            target_path=target_path,
            operation=OperationType.MOVE,
            metadata=metadata,
            dry_run=dry_run
        )
    
    def _generate_target_path(self, metadata: MovieMetadata) -> str:
        """根据元数据生成目标路径
        
        支持的模板变量:
            {code}: 视频代码
            {title}: 标题
            {actor}: 演员（第一个）
            {actors}: 演员（全部，逗号分隔）
            {studio}: 制作商
            {year}: 年份
            {date}: 完整日期
            {site}: 网站名
        
        示例:
            模板: "{base_dir}/{studio}/{code} {title}"
            结果: "/videos/S1/SSIS-123 美少女"
        """
        pass
    
    def _resolve_conflict(self, path: str) -> str:
        """解决文件名冲突
        
        策略:
            - skip: 跳过，不覆盖
            - rename: 重命名（添加后缀）
            - overwrite: 覆盖
        """
        pass
```

**预计工作量**: 2 天

---

#### 2.2.5 执行器扩展

**任务 4.6: 扩展执行器支持文件操作**
- [ ] **位置**: `pavone/core/execution.py` (扩展现有)
- [ ] **新增功能**:
  - 支持 MOVE/COPY/RENAME 操作
  - 文件操作前验证（源文件存在、目标目录权限等）
  - 支持回滚（操作失败时恢复）

**示例**:
```python
class Executor:
    # 现有功能...
    
    async def execute_file_operation(
        self, 
        item: FileOperationItem,
        progress_callback: Optional[Callable] = None
    ) -> bool:
        """执行文件操作
        
        Args:
            item: 文件操作项
            progress_callback: 进度回调
        
        Returns:
            是否成功
        """
        try:
            # 1. 验证源文件
            if not os.path.exists(item.source_path):
                self.logger.error(f"源文件不存在: {item.source_path}")
                return False
            
            # 2. 创建目标目录
            target_dir = os.path.dirname(item.target_path)
            os.makedirs(target_dir, exist_ok=True)
            
            # 3. 执行操作
            if item.operation == OperationType.MOVE:
                shutil.move(item.source_path, item.target_path)
            elif item.operation == OperationType.COPY:
                shutil.copy2(item.source_path, item.target_path)
            elif item.operation == OperationType.RENAME:
                os.rename(item.source_path, item.target_path)
            
            # 4. 保存元数据（如果有）
            if item.metadata:
                self._save_metadata_files(item.target_path, item.metadata)
            
            self.logger.info(f"文件操作成功: {item.source_path} -> {item.target_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"文件操作失败: {e}")
            return False
    
    def _save_metadata_files(self, video_path: str, metadata: MovieMetadata):
        """保存元数据文件（NFO、海报等）
        
        生成:
            - video.nfo: Kodi格式的元数据
            - poster.jpg: 海报图片
            - fanart.jpg: 背景图片
        """
        pass
```

**预计工作量**: 2 天

---

#### 2.2.6 CLI 命令实现

**任务 4.7: 创建 organize 命令**
- [ ] **位置**: `pavone/cli/commands/organize.py`
- [ ] **功能**:
  - 扫描指定目录的视频文件
  - 批量处理文件
  - 支持预览模式（dry-run）
  - 支持过滤和排除规则

**命令设计**:
```bash
# 基本用法
pavone organize /path/to/videos --output-dir /path/to/organized

# 预览模式（不实际移动文件）
pavone organize /path/to/videos --output-dir /path/to/organized --dry-run

# 指定文件名模板
pavone organize /path/to/videos \
    --output-dir /path/to/organized \
    --structure "{studio}/{code} {title}" \
    --filename "{code}"

# 指定插件优先级
pavone organize /path/to/videos \
    --output-dir /path/to/organized \
    --plugins missav,jtable,memojav

# 排除某些文件
pavone organize /path/to/videos \
    --output-dir /path/to/organized \
    --exclude "*.txt" \
    --exclude "*sample*"

# 递归处理子目录
pavone organize /path/to/videos \
    --output-dir /path/to/organized \
    --recursive

# 冲突处理策略
pavone organize /path/to/videos \
    --output-dir /path/to/organized \
    --on-conflict rename  # skip, rename, overwrite
```

**实现**:
```python
import click
from pathlib import Path
from typing import List, Optional

from ...core.search_manager import SearchManager
from ...core.metadata_manager import MetadataManager
from ...core.execution import Executor
from ...utils.filename_utils import FilenameParser
from ...utils.file_operation_builder import FileOperationBuilder
from ..commands.utils import (
    common_output_options,
    common_interaction_options,
)

@click.command()
@click.argument("input_dir", type=click.Path(exists=True))
@click.option(
    "--output-dir",
    "-o",
    type=click.Path(),
    required=True,
    help="整理后的输出目录"
)
@click.option(
    "--structure",
    default="{code}",
    help="目录结构模板，如: {studio}/{code} {title}"
)
@click.option(
    "--filename",
    default="{code}",
    help="文件名模板，如: {code} {title}"
)
@click.option(
    "--plugins",
    help="指定搜索插件（逗号分隔），如: missav,jtable"
)
@click.option(
    "--exclude",
    multiple=True,
    help="排除文件模式（支持通配符）"
)
@click.option(
    "--recursive/--no-recursive",
    default=False,
    help="是否递归处理子目录"
)
@click.option(
    "--dry-run",
    is_flag=True,
    help="预览模式，不实际移动文件"
)
@click.option(
    "--on-conflict",
    type=click.Choice(["skip", "rename", "overwrite"]),
    default="rename",
    help="文件名冲突处理策略"
)
@common_output_options
@common_interaction_options
def organize(
    input_dir: str,
    output_dir: str,
    structure: str,
    filename: str,
    plugins: Optional[str],
    exclude: tuple,
    recursive: bool,
    dry_run: bool,
    on_conflict: str,
    **kwargs
):
    """整理视频文件
    
    扫描指定目录的视频文件，通过搜索和元数据提取，
    自动生成标准化的文件名和目录结构。
    
    示例:
        pavone organize /downloads --output-dir /videos
        pavone organize /downloads -o /videos --dry-run
        pavone organize /downloads -o /videos --structure "{studio}/{code}"
    """
    # 1. 初始化管理器
    search_manager = SearchManager(plugin_manager)
    metadata_manager = MetadataManager(plugin_manager)
    file_operation_builder = FileOperationBuilder({
        'base_dir': output_dir,
        'structure': structure,
        'filename': filename,
        'conflict_resolution': on_conflict
    })
    executor = Executor()
    
    # 2. 扫描视频文件
    video_files = _scan_video_files(
        input_dir, 
        recursive=recursive, 
        exclude=exclude
    )
    
    if not video_files:
        click.echo("未找到视频文件")
        return
    
    click.echo(f"找到 {len(video_files)} 个视频文件")
    
    # 3. 处理每个文件
    success_count = 0
    failed_count = 0
    
    for video_file in video_files:
        try:
            # 3.1 从文件名提取代码
            code = FilenameParser.extract_code(video_file.name)
            if not code:
                click.echo(f"⚠️  无法提取代码: {video_file.name}")
                failed_count += 1
                continue
            
            click.echo(f"\n处理: {video_file.name} (代码: {code})")
            
            # 3.2 搜索获取链接
            plugin_list = plugins.split(",") if plugins else None
            search_result = search_manager.get_best_match(
                code, 
                filters={'plugins': plugin_list}
            )
            
            if not search_result:
                click.echo(f"⚠️  未找到搜索结果: {code}")
                failed_count += 1
                continue
            
            # 3.3 获取元数据
            metadata = metadata_manager.get_metadata_from_search_result(
                search_result
            )
            
            if not metadata:
                click.echo(f"⚠️  无法获取元数据: {code}")
                failed_count += 1
                continue
            
            # 3.4 生成操作项
            operation_item = file_operation_builder.build_move_operation(
                source_path=str(video_file),
                metadata=metadata,
                dry_run=dry_run
            )
            
            # 3.5 显示操作信息
            click.echo(f"  源文件: {operation_item.source_path}")
            click.echo(f"  目标文件: {operation_item.target_path}")
            
            if dry_run:
                click.echo("  [预览模式] 跳过实际操作")
                success_count += 1
                continue
            
            # 3.6 执行操作
            result = await executor.execute_file_operation(operation_item)
            
            if result:
                click.echo("✅ 处理成功")
                success_count += 1
            else:
                click.echo("❌ 处理失败")
                failed_count += 1
                
        except Exception as e:
            click.echo(f"❌ 处理异常: {e}")
            failed_count += 1
    
    # 4. 显示总结
    click.echo(f"\n{'='*50}")
    click.echo(f"处理完成:")
    click.echo(f"  成功: {success_count}")
    click.echo(f"  失败: {failed_count}")
    click.echo(f"  总计: {len(video_files)}")
    if dry_run:
        click.echo("\n💡 这是预览模式，文件未实际移动")


def _scan_video_files(
    directory: str, 
    recursive: bool = False,
    exclude: tuple = ()
) -> List[Path]:
    """扫描视频文件
    
    Args:
        directory: 目录路径
        recursive: 是否递归
        exclude: 排除模式列表
    
    Returns:
        视频文件路径列表
    """
    video_extensions = ['.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv', '.ts']
    path = Path(directory)
    
    if recursive:
        files = path.rglob('*')
    else:
        files = path.glob('*')
    
    # 过滤视频文件
    video_files = [
        f for f in files 
        if f.is_file() and f.suffix.lower() in video_extensions
    ]
    
    # 应用排除规则
    if exclude:
        from fnmatch import fnmatch
        video_files = [
            f for f in video_files
            if not any(fnmatch(f.name, pattern) for pattern in exclude)
        ]
    
    return sorted(video_files)
```

**预计工作量**: 2-3 天

---

### 2.3 配置支持

**任务 4.8: 添加配置项**
- [ ] **位置**: `pavone/config/settings.py`
- [ ] **新增配置**:

```python
# 文件整理配置
ORGANIZE_DEFAULT_STRUCTURE = "{code}"
ORGANIZE_DEFAULT_FILENAME = "{code} {title}"
ORGANIZE_CONFLICT_RESOLUTION = "rename"  # skip, rename, overwrite
ORGANIZE_SAVE_METADATA = True  # 是否保存元数据文件
ORGANIZE_SAVE_COVER = True  # 是否保存封面图片
ORGANIZE_SUPPORTED_EXTENSIONS = ['.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv', '.ts']
```

**任务 4.9: 文档更新**
- [ ] **使用指南**: `docs/usage.md`
- [ ] **配置说明**: `docs/config.md`
- [ ] **示例**: `docs/examples/organize.md`

**预计工作量**: 1 天

---

## 3. 测试策略

### 3.1 单元测试

#### 插件测试
- [ ] `JTablePlugin` 完整测试
  - 搜索功能
  - 元数据提取
  - 下载链接提取
- [ ] `MemojavPlugin` 完整测试
  - 搜索功能
  - 元数据提取
  - 下载链接提取

#### 工具类测试
- [ ] `FilenameParser` 测试
  - 各种文件名格式
  - 边界情况
- [ ] `FileOperationBuilder` 测试
  - 路径生成
  - 冲突处理
- [ ] `SearchManager` 测试
  - 优先级排序
  - 结果合并

#### 执行器测试
- [ ] 文件操作测试
  - MOVE 操作
  - COPY 操作
  - RENAME 操作
  - 回滚机制

**目标覆盖率**: > 85%

### 3.2 集成测试

- [ ] 端到端测试
  - 搜索 → 元数据 → 下载
  - 文件整理完整流程
- [ ] 跨插件测试
  - 多插件搜索
  - 搜索结果优先级

### 3.3 性能测试

- [ ] 批量文件处理性能
- [ ] 搜索响应时间
- [ ] 元数据获取并发性能

---

## 4. 文档更新

### 4.1 开发者文档
- [ ] 插件开发指南更新
  - 复合型插件最佳实践
  - 搜索接口规范
- [ ] 架构设计文档
  - 文件整理流程图
  - 组件交互图

### 4.2 用户文档
- [ ] 使用指南
  - organize 命令详细说明
  - 模板变量参考
  - 配置示例
- [ ] FAQ
  - 常见问题解答
  - 故障排查

### 4.3 变更日志
- [ ] 详细记录所有新功能
- [ ] API 变更说明
- [ ] 迁移指南（如有破坏性变更）

---

## 5. 时间线

| 阶段 | 任务 | 预计时间 | 依赖 |
|------|------|---------|------|
| Week 1 | JTable 插件升级（搜索 + 元数据 + 下载） | 3-4 天 | v0.2.1 |
| Week 1-2 | Memojav 插件升级（搜索 + 元数据 + 下载） | 3-4 天 | v0.2.1 |
| Week 2 | 文件名解析工具 + 搜索管理器 | 2-3 天 | - |
| Week 2-3 | 文件操作构建器 + 执行器扩展 | 3-4 天 | - |
| Week 3 | organize 命令实现 | 2-3 天 | 所有核心功能 |
| Week 3-4 | 测试（单元 + 集成 + 性能） | 3-4 天 | 所有功能完成 |
| Week 4 | 文档更新 + 发布准备 | 2-3 天 | 测试通过 |

**总预计时间**: 3-4 周

---

## 6. 成功标准

### 6.1 功能完整性
- ✅ JTable 和 Memojav 支持搜索、元数据、下载三种功能
- ✅ organize 命令正常工作
- ✅ 支持多种文件名模板
- ✅ 支持冲突处理策略

### 6.2 代码质量
- ✅ 测试覆盖率 > 85%
- ✅ 所有 pyright 检查通过（0 errors）
- ✅ 代码风格统一

### 6.3 性能指标
- ✅ 单文件整理时间 < 10s（网络正常情况）
- ✅ 批量处理支持并发
- ✅ 搜索响应时间 < 3s

### 6.4 用户体验
- ✅ CLI 界面友好，提示清晰
- ✅ 支持预览模式（dry-run）
- ✅ 错误处理完善
- ✅ 文档完整准确

---

## 7. 风险评估

### 7.1 技术风险

**风险**: 搜索功能依赖网站结构，可能变化
- **缓解**: 
  - 设计灵活的解析器
  - 添加降级方案
  - 及时更新维护

**风险**: 文件操作可能导致数据丢失
- **缓解**:
  - 强制使用 dry-run 预览
  - 添加确认提示
  - 实现回滚机制
  - 详细日志记录

**风险**: 文件名模板可能产生非法路径
- **缓解**:
  - 严格验证模板
  - 过滤非法字符
  - 路径长度检查

### 7.2 兼容性风险

**风险**: 插件升级可能影响现有用户
- **缓解**:
  - 保持向后兼容
  - 提供迁移工具
  - 详细的升级指南

### 7.3 时间风险

**风险**: 工作量可能超出预期
- **缓解**:
  - 分阶段开发
  - 优先完成核心功能
  - 预留缓冲时间

---

## 8. 发布检查清单

### 8.1 代码
- [ ] 所有新功能已实现
- [ ] 所有单元测试通过
- [ ] 所有集成测试通过
- [ ] 性能测试通过
- [ ] Pyright 检查通过（0 errors）
- [ ] 代码审查完成

### 8.2 文档
- [ ] API 文档已更新
- [ ] 用户文档已更新
- [ ] 变更日志已更新
- [ ] README 已更新
- [ ] 示例代码已验证

### 8.3 发布
- [ ] 版本号确认为 0.2.2
- [ ] 创建 Git 标签
- [ ] 准备发布说明
- [ ] 更新依赖版本

---

## 9. 后续规划

### 9.1 v0.2.3 候选功能
- 更多网站支持（DMM, MGS 等）
- 字幕文件处理
- 重复文件检测
- Web UI 界面

### 9.2 长期目标
- 插件市场
- 云端元数据同步
- 移动端支持
- 社区贡献平台

---

## 附录

### A. 文件名模板变量参考

| 变量 | 说明 | 示例 |
|------|------|------|
| `{code}` | 视频代码 | `SSIS-123` |
| `{title}` | 标题 | `美少女` |
| `{actor}` | 主演（第一个） | `三上悠亜` |
| `{actors}` | 所有主演（逗号分隔） | `三上悠亜,橋本ありな` |
| `{studio}` | 制作商 | `S1` |
| `{label}` | 发行商 | `S1 NO.1 STYLE` |
| `{year}` | 年份 | `2024` |
| `{date}` | 完整日期 | `2024-01-01` |
| `{site}` | 网站名 | `MissAV` |
| `{genres}` | 类型（逗号分隔） | `美少女,单体作品` |

### B. 目录结构模板示例

```bash
# 按制作商分类
{studio}/{code} {title}
# 示例: S1/SSIS-123 美少女

# 按年份和制作商分类
{year}/{studio}/{code}
# 示例: 2024/S1/SSIS-123

# 按演员分类
{actor}/{code} {title}
# 示例: 三上悠亜/SSIS-123 美少女

# 多级分类
{year}/{studio}/{actor}/{code}
# 示例: 2024/S1/三上悠亜/SSIS-123

# 仅代码（扁平结构）
{code}
# 示例: SSIS-123
```

### C. 配置文件示例

```yaml
# config.yaml

# 文件整理配置
organize:
  # 默认目录结构模板
  structure: "{studio}/{code} {title}"
  
  # 默认文件名模板
  filename: "{code}"
  
  # 冲突处理策略: skip, rename, overwrite
  on_conflict: rename
  
  # 是否保存元数据文件
  save_metadata: true
  
  # 是否下载封面图片
  save_cover: true
  
  # 支持的视频扩展名
  video_extensions:
    - .mp4
    - .mkv
    - .avi
    - .mov
    - .wmv
    - .flv
    - .ts
  
  # 搜索插件优先级
  search_priority:
    - missav
    - jtable
    - memojav
    - av01
```
